<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>D&D Fog of War Map Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body { overscroll-behavior: none; }
      /* For custom scrollbars in the playlist */
      .map-playlist::-webkit-scrollbar { width: 8px; }
      .map-playlist::-webkit-scrollbar-track { background: #1f2937; } /* bg-gray-800 */
      .map-playlist::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; } /* bg-gray-600 */
      .map-playlist::-webkit-scrollbar-thumb:hover { background: #6b7280; } /* bg-gray-500 */
    </style>
    <!-- Load React, ReactDOM, and Babel for in-browser JSX/TSX transpilation -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="bg-gray-900 text-white antialiased">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
      // --- HOOKS ---
      const useMapSync = (mode) => {
        const { useState, useEffect, useRef, useCallback } = React;
        const CHANNEL_NAME = 'dnd-map-sync-channel';

        const [mapState, setMapState] = useState({
          mapUrl: null,
          mapType: null,
          mapAspectRatio: 16 / 9,
          zoom: 1,
          pan: { x: 0, y: 0 },
          rotation: 0,
          gridVisible: false,
          gridSize: 50,
          gridColor: '#FFFFFF',
          gridOpacity: 0.5,
          fogEnabled: false,
          fogShapes: [],
        });

        const channel = useRef(null);

        useEffect(() => {
          channel.current = new BroadcastChannel(CHANNEL_NAME);

          const handleMessage = (event) => {
            if (event.data.type === 'STATE_UPDATE' && mode === 'player') {
              setMapState(event.data.payload);
            }
          };

          channel.current.addEventListener('message', handleMessage);

          return () => {
            channel.current?.removeEventListener('message', handleMessage);
            channel.current?.close();
          };
        }, [mode]);

        const broadcastState = useCallback((newState) => {
            if (mode === 'dm' && channel.current) {
                const message = {
                    type: 'STATE_UPDATE',
                    payload: newState,
                };
                channel.current.postMessage(message);
            }
        }, [mode]);
        
        const updateMapState = useCallback((update) => {
          setMapState(currentState => {
            const newState = typeof update === 'function' ? update(currentState) : { ...currentState, ...update };
            broadcastState(newState);
            return newState;
          });
        }, [broadcastState]);
        
        return { mapState, updateMapState };
      }


      // --- COMPONENTS ---
      
      const FogOfWarOverlay = ({ enabled, fogShapes, isDMView = false }) => {
        if (!enabled) return null;
        
        const maskId = "fog-of-war-mask";
        const fogColor = isDMView ? 'rgba(31, 41, 55, 0.75)' : 'black';

        return (
          <svg className="absolute top-0 left-0 w-full h-full pointer-events-none" style={{ zIndex: 20 }}>
            <defs>
              <mask id={maskId}>
                <rect x="0" y="0" width="100%" height="100%" fill="white" />
                {fogShapes.map((shape, index) => (
                  <rect
                    key={`shape-${index}`}
                    x={`${shape.x * 100}%`}
                    y={`${shape.y * 100}%`}
                    width={`${shape.width * 100}%`}
                    height={`${shape.height * 100}%`}
                    fill={shape.type === 'reveal' ? 'black' : 'white'}
                  />
                ))}
              </mask>
            </defs>
            <rect x="0" y="0" width="100%" height="100%" fill={fogColor} mask={`url(#${maskId})`} />
          </svg>
        );
      };
      
      const DrawingOverlay = ({ drawingRect, mode }) => {
        if (!drawingRect) return null;
        
        const style = {
            left: `${drawingRect.x * 100}%`,
            top: `${drawingRect.y * 100}%`,
            width: `${drawingRect.width * 100}%`,
            height: `${drawingRect.height * 100}%`,
            borderColor: mode === 'reveal' ? 'rgba(255, 255, 255, 0.7)' : 'rgba(255, 0, 0, 0.7)',
            borderWidth: '2px',
            borderStyle: 'dashed',
            position: 'absolute',
            pointerEvents: 'none',
            zIndex: 30,
        };

        return <div style={style} />;
      };

      const GridOverlay = ({ mapState }) => {
        const { gridVisible, gridSize, gridColor, gridOpacity, zoom } = mapState;

        if (!gridVisible || !gridSize || gridSize <= 0) return null;

        // We draw the grid at 1:1 scale relative to the image, so zoom is handled by the parent transform
        const patternId = "grid-pattern";
        
        return (
          <svg className="absolute top-0 left-0 w-full h-full pointer-events-none" style={{ opacity: gridOpacity, zIndex: 10 }}>
            <defs>
              <pattern id={patternId} patternUnits="userSpaceOnUse" width={gridSize} height={gridSize}>
                <path d={`M ${gridSize} 0 L 0 0 0 ${gridSize}`} fill="none" stroke={gridColor} strokeWidth={1} />
              </pattern>
            </defs>
            <rect width="100%" height="100%" fill={`url(#${patternId})`} />
          </svg>
        );
      };

      const PlayerView = () => {
        const { useRef } = React;
        const { mapState } = useMapSync('player');
        const viewRef = useRef(null);

        const toggleFullscreen = () => {
          if (!document.fullscreenElement && viewRef.current) {
            viewRef.current.requestFullscreen().catch(err => {
              alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            });
          } else if (document.fullscreenElement) {
            document.exitFullscreen();
          }
        };
        
        const mapTransform = `translate(${mapState.pan.x}px, ${mapState.pan.y}px) scale(${mapState.zoom}) rotate(${mapState.rotation}deg)`;

        return (
          <div ref={viewRef} className="w-screen h-screen bg-black flex items-center justify-center relative group overflow-hidden">
            {mapState.mapUrl ? (
                 <div 
                    style={{ 
                        aspectRatio: mapState.mapAspectRatio,
                        width: 'auto',
                        height: 'auto',
                        maxWidth: '100%',
                        maxHeight: '100%',
                        transform: mapTransform,
                        transformOrigin: 'center center',
                    }}
                    className="relative shadow-lg"
                >
                    {mapState.mapType === 'image' ? (
                        <img src={mapState.mapUrl} alt="D&D Map" className="w-full h-full object-cover block" draggable="false" />
                    ) : (
                        <video src={mapState.mapUrl} loop autoPlay muted className="w-full h-full object-cover block" draggable="false" />
                    )}
                    <GridOverlay mapState={mapState} />
                    <FogOfWarOverlay enabled={mapState.fogEnabled} fogShapes={mapState.fogShapes} />
                </div>
            ) : (
              <div className="text-gray-500 text-2xl">Waiting for DM to load a map...</div>
            )}

            <button 
              onClick={toggleFullscreen}
              className="absolute bottom-4 right-4 bg-gray-800 bg-opacity-50 text-white p-2 rounded-full opacity-0 group-hover:opacity-100 transition-opacity focus:opacity-100"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 8V4m0 0h4M4 4l5 5m11-1v4m0 0h-4m4 0l-5-5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 0h-4m4 0l-5 5" />
              </svg>
            </button>
          </div>
        );
      };

      const DMView = () => {
        const { useState, useRef } = React;
        const { mapState, updateMapState } = useMapSync('dm');
        const mapContainerRef = useRef(null); // The static viewport
        const mapContentRef = useRef(null);   // The transformed content wrapper
        const [playlist, setPlaylist] = useState([]);
        const [activeMapIndex, setActiveMapIndex] = useState(null);
        const [toolMode, setToolMode] = useState('pan'); // 'pan' or 'fog'
        
        const [interactionState, setInteractionState] = useState({ mode: 'idle', start: { x: 0, y: 0 }});
        const [drawingRect, setDrawingRect] = useState(null);

        const resetView = () => {
            updateMapState({
                zoom: 1,
                pan: { x: 0, y: 0 },
                rotation: 0,
            });
        };
        
        const handleRotate = () => {
          updateMapState(s => ({ ...s, rotation: (s.rotation + 90) % 360 }));
        };
        
        const resetFog = () => {
            if (confirm('Are you sure you want to clear all fog changes?')) {
                updateMapState({ fogShapes: [] });
            }
        };

        const loadMap = (file, index) => {
          if (!file) return;

          setActiveMapIndex(index);
          const reader = new FileReader();
          reader.onload = (event) => {
            const url = event.target.result;
            const isVideo = file.type.startsWith('video');
            const mapType = isVideo ? 'video' : 'image';
            
            const mediaElement = document.createElement(isVideo ? 'video' : 'img');
            
            mediaElement.onload = mediaElement.onloadedmetadata = () => {
              const aspectRatio = mapType === 'image' 
                ? mediaElement.naturalWidth / mediaElement.naturalHeight
                : mediaElement.videoWidth / mediaElement.videoHeight;
              
              updateMapState({
                  mapUrl: url,
                  mapType: mapType,
                  mapAspectRatio: isFinite(aspectRatio) && aspectRatio > 0 ? aspectRatio : 16/9,
                  zoom: 1, pan: { x: 0, y: 0 }, rotation: 0,
                  fogEnabled: true, fogShapes: [],
              });
            };
            mediaElement.src = url;
          };
          reader.readAsDataURL(file);
        };

        const handleFolderSelect = (e) => {
            const files = Array.from(e.target.files);
            const supportedTypes = /^(image\/(jpeg|png|gif|webp))|(video\/(mp4|webm|ogg))$/;
            
            const validFiles = files.filter(file => 
              supportedTypes.test(file.type) && (!file.webkitRelativePath || file.webkitRelativePath.split('/').length === 2)
            );
            
            setPlaylist(validFiles);

            if (validFiles.length > 0) {
                loadMap(validFiles[0], 0);
            } else {
                alert("No valid files found in the folder root.");
            }
        };

        const handleWheel = (e) => {
            e.preventDefault();
            const ZOOM_SENSITIVITY = 0.001;
            updateMapState(s => {
              const newZoom = s.zoom - e.deltaY * ZOOM_SENSITIVITY;
              return { ...s, zoom: Math.min(Math.max(0.1, newZoom), 10) };
            });
        };

        // Helper to convert screen client coordinates to normalized (0-1) map coordinates
        // accounting for Pan, Zoom, and Rotation.
        const getNormalizedPoint = (clientX, clientY) => {
            if (!mapContainerRef.current || !mapContentRef.current) return { x: 0, y: 0 };

            const containerRect = mapContainerRef.current.getBoundingClientRect();
            
            // 1. Center of the viewport (the transform origin)
            const cx = containerRect.left + containerRect.width / 2;
            const cy = containerRect.top + containerRect.height / 2;

            // 2. Vector from center to mouse
            let vx = clientX - cx;
            let vy = clientY - cy;

            // 3. Undo Translation (Pan)
            // Note: CSS translate moves the element relative to its origin. 
            // The mouse "moves" in the opposite direction relative to the element.
            vx -= mapState.pan.x;
            vy -= mapState.pan.y;

            // 4. Undo Scale (Zoom)
            vx /= mapState.zoom;
            vy /= mapState.zoom;

            // 5. Undo Rotation
            // CSS rotate is clockwise (positive). Math rotate is usually CCW.
            // To undo a clockwise rotation, we rotate CCW by the same amount (or CW by -angle).
            // Formula: x' = x cos(theta) - y sin(theta), y' = x sin(theta) + y cos(theta)
            // Here theta = -rotation (in radians)
            const rad = -mapState.rotation * (Math.PI / 180);
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            
            const rvx = vx * cos - vy * sin;
            const rvy = vx * sin + vy * cos;

            // 6. Normalize to content dimensions
            // offsetWidth/Height give the UNTRANSFORMED layout size of the content box.
            const w = mapContentRef.current.offsetWidth;
            const h = mapContentRef.current.offsetHeight;

            // The coordinate system of the content box has (0,0) at its center because of the transform logic?
            // Wait, CSS transform-origin 'center center' means the pivot is the center.
            // So our (rvx, rvy) is relative to the center of the image.
            // We need to map (-w/2, -h/2) to (0,0) and (w/2, h/2) to (1,1).
            
            const x = (rvx + w / 2) / w;
            const y = (rvy + h / 2) / h;

            return { x, y };
        };

        const handleMouseDown = (e) => {
            e.preventDefault();
            if (!mapContainerRef.current) return;
            let mode = 'idle';

            if (e.button === 1) {
                mode = 'panning';
            } else if (toolMode === 'pan' && e.button === 0) {
                mode = 'panning';
            } else if (toolMode === 'fog' && mapState.fogEnabled) {
                if (e.button === 0) mode = 'drawing_reveal';
                if (e.button === 2) mode = 'drawing_hide';
            }
            
            if (mode === 'panning' && mapContainerRef.current) {
                mapContainerRef.current.style.cursor = 'grabbing';
            }
            
            setInteractionState({ mode, start: { x: e.clientX, y: e.clientY } });
        };

        const handleMouseUp = (e) => {
            e.preventDefault();
            
            let cursorStyle = 'default';
            if (toolMode === 'pan') cursorStyle = 'grab';
            else if (toolMode === 'fog' && mapState.fogEnabled) cursorStyle = 'crosshair';
            
            if (mapContainerRef.current) {
                mapContainerRef.current.style.cursor = cursorStyle;
            }

            if (drawingRect) {
                const type = interactionState.mode === 'drawing_reveal' ? 'reveal' : 'hide';
                updateMapState(s => ({ ...s, fogShapes: [...s.fogShapes, { ...drawingRect, type }] }));
            }

            setInteractionState({ mode: 'idle', start: { x: 0, y: 0 } });
            setDrawingRect(null);
        };

        const handleMouseMove = (e) => {
            if (interactionState.mode === 'idle') return;
            e.preventDefault();

            if (interactionState.mode === 'panning') {
                const dx = e.clientX - interactionState.start.x;
                const dy = e.clientY - interactionState.start.y;
                setInteractionState(s => ({ ...s, start: { x: e.clientX, y: e.clientY } }));
                updateMapState(s => ({ ...s, pan: { x: s.pan.x + dx, y: s.pan.y + dy } }));
            } else if (interactionState.mode.startsWith('drawing')) {
                const startPt = getNormalizedPoint(interactionState.start.x, interactionState.start.y);
                const currPt = getNormalizedPoint(e.clientX, e.clientY);

                const rect = {
                    x: Math.min(startPt.x, currPt.x),
                    y: Math.min(startPt.y, currPt.y),
                    width: Math.abs(currPt.x - startPt.x),
                    height: Math.abs(currPt.y - startPt.y),
                };
                setDrawingRect(rect);
            }
        };
        
        const openPlayerView = () => {
          window.open(`${window.location.href.split('#')[0]}#/player`, '_blank');
        };

        const mapTransform = `translate(${mapState.pan.x}px, ${mapState.pan.y}px) scale(${mapState.zoom}) rotate(${mapState.rotation}deg)`;
        
        let cursorStyle = 'default';
        if (mapState.mapUrl) {
            if (interactionState.mode === 'panning') cursorStyle = 'grabbing';
            else if (toolMode === 'pan') cursorStyle = 'grab';
            else if (toolMode === 'fog' && mapState.fogEnabled) cursorStyle = 'crosshair';
        }
        
        return (
          <div className="flex h-screen bg-gray-800">
            {/* --- CONTROLS SIDEBAR (LEFT) --- */}
            <aside className="w-72 flex-shrink-0 bg-gray-900 p-4 flex flex-col space-y-2 border-r border-gray-700 overflow-y-auto">
              <h1 className="text-xl font-bold text-center mb-2">DM Controls</h1>
              
              <div>
                <label htmlFor="map-folder-upload" className="w-full cursor-pointer bg-violet-600 hover:bg-violet-700 text-white font-bold py-2 px-4 rounded transition-colors text-center block">
                  Load Map Folder
                </label>
                <input id="map-folder-upload" type="file" webkitdirectory="" directory="" multiple onChange={handleFolderSelect} className="hidden" />
              </div>

              <button onClick={openPlayerView} className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition-colors">
                Open Player View
              </button>
              
              <div className="grid grid-cols-2 gap-2">
                <button onClick={resetView} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded transition-colors">
                  Reset View
                </button>
                <button onClick={handleRotate} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded transition-colors">
                  Rotate 90Â°
                </button>
              </div>

              <div className="pt-2 border-t border-gray-700">
                <h2 className="text-lg font-semibold my-2">Tool Mode</h2>
                <div className="flex rounded-md shadow-sm">
                  <button
                    onClick={() => setToolMode('pan')}
                    className={`flex-1 py-2 px-4 text-sm font-medium rounded-l-md transition-colors ${toolMode === 'pan' ? 'bg-blue-600 text-white' : 'bg-gray-600 hover:bg-gray-700'}`}
                  >
                    Pan & Zoom
                  </button>
                  <button
                    onClick={() => setToolMode('fog')}
                    disabled={!mapState.fogEnabled}
                    className={`flex-1 py-2 px-4 text-sm font-medium rounded-r-md transition-colors ${toolMode === 'fog' ? 'bg-blue-600 text-white' : 'bg-gray-600 hover:bg-gray-700 disabled:bg-gray-800 disabled:text-gray-500 disabled:cursor-not-allowed'}`}
                  >
                    Edit Fog
                  </button>
                </div>
              </div>
              
              <div className="pt-2 border-t border-gray-700 space-y-3">
                <h2 className="text-lg font-semibold mt-2">Grid Settings</h2>
                <label className="flex items-center justify-between cursor-pointer">
                  <span>Show Grid</span>
                  <input type="checkbox" checked={mapState.gridVisible} onChange={(e) => updateMapState({ gridVisible: e.target.checked })} className="form-checkbox h-5 w-5 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500" />
                </label>
                <div>
                  <div className="flex justify-between items-center mb-1">
                    <label htmlFor="grid-size" className="block text-sm font-medium">Grid Size (px)</label>
                    <input 
                      type="number" 
                      min="10" 
                      max="500" 
                      value={mapState.gridSize} 
                      onChange={(e) => {
                        const val = Number(e.target.value);
                        updateMapState({ gridSize: val > 0 ? val : 10 });
                      }}
                      className="w-20 bg-gray-700 text-white text-sm rounded px-2 py-1 border border-gray-600 focus:border-blue-500 focus:outline-none text-right"
                    />
                  </div>
                  <input type="range" id="grid-size" min="10" max="200" value={mapState.gridSize} onChange={(e) => updateMapState({ gridSize: Number(e.target.value) })} className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" />
                </div>
              </div>
              
              <div className="pt-2 border-t border-gray-700 space-y-3">
                <h2 className="text-lg font-semibold mt-2">Fog of War</h2>
                <label className="flex items-center justify-between cursor-pointer">
                  <span>Enable Fog</span>
                  <input type="checkbox" checked={mapState.fogEnabled} disabled={!mapState.mapUrl} onChange={(e) => updateMapState({ fogEnabled: e.target.checked })} className="form-checkbox h-5 w-5 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500 disabled:opacity-50" />
                </label>
                <button onClick={resetFog} disabled={!mapState.fogEnabled} className="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition-colors disabled:bg-gray-600 disabled:cursor-not-allowed">
                  Clear Fog
                </button>
              </div>

              <div className="pt-4 mt-auto border-t border-gray-700 text-sm text-gray-400">
                  <h2 className="text-lg font-semibold mb-2 text-white">How to Use</h2>
                  <ul className="list-disc pl-4 space-y-1">
                      <li><strong>Load Map:</strong> Select a folder.</li>
                      <li><strong>Pan/Zoom:</strong> 'Pan & Zoom' mode.</li>
                      <li><strong>Fog:</strong> 'Edit Fog'. Left to reveal, Right to hide.</li>
                      <li><strong>Player View:</strong> Open separate window.</li>
                      <li><em>Tip: Middle mouse always pans.</em></li>
                  </ul>
              </div>

            </aside>
            
            {/* --- MAP PREVIEW AREA (CENTER) --- */}
            <main 
              className="flex-1 flex items-center justify-center p-4 bg-black overflow-hidden"
              onMouseDown={handleMouseDown}
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
              onMouseLeave={handleMouseUp}
              onContextMenu={(e) => e.preventDefault()}
            >
              {mapState.mapUrl ? (
                <div 
                  ref={mapContainerRef}
                  className="relative w-full h-full flex items-center justify-center overflow-hidden" 
                  style={{ cursor: cursorStyle }}
                  onWheel={handleWheel}
                >
                    {/* Constrained aspect ratio container */}
                    <div 
                      ref={mapContentRef}
                      style={{
                        aspectRatio: mapState.mapAspectRatio,
                        width: 'auto',
                        height: 'auto',
                        maxWidth: '100%',
                        maxHeight: '100%',
                        transform: mapTransform,
                        transformOrigin: 'center center',
                      }}
                      className="relative shadow-lg"
                    >
                      {mapState.mapType === 'image' ? (
                        <img src={mapState.mapUrl} alt="D&D Map" className="w-full h-full object-cover block" draggable="false" />
                      ) : (
                        <video src={mapState.mapUrl} loop autoPlay muted className="w-full h-full object-cover block" draggable="false" />
                      )}
                      <GridOverlay mapState={mapState} />
                      <FogOfWarOverlay enabled={mapState.fogEnabled} fogShapes={mapState.fogShapes} isDMView={true} />
                      <DrawingOverlay drawingRect={drawingRect} mode={interactionState.mode === 'drawing_reveal' ? 'reveal' : 'hide'} />
                    </div>
                </div>
              ) : (
                  <div className="w-full h-full flex items-center justify-center bg-gray-700 text-gray-400 rounded-lg">
                      <div className="text-center">
                          <p className="text-lg font-semibold">Load a map folder to begin</p>
                          <p className="text-sm text-gray-500">Only files in the folder's root will be shown.</p>
                      </div>
                  </div>
              )}
            </main>

            {/* --- PLAYLIST SIDEBAR (RIGHT) --- */}
             {playlist.length > 0 && (
                <aside className="w-72 flex-shrink-0 bg-gray-900 p-4 flex flex-col border-l border-gray-700">
                  <h2 className="text-lg font-semibold mb-2 flex-shrink-0">Map Playlist</h2>
                  <ul className="map-playlist overflow-y-auto flex-grow pr-1">
                    {playlist.map((file, index) => (
                      <li key={file.name + index}>
                        <button onClick={() => loadMap(file, index)} className={`w-full text-left text-sm p-2 rounded truncate transition-colors ${activeMapIndex === index ? 'bg-blue-600 text-white' : 'hover:bg-gray-700'}`} title={file.name}>
                          {file.name}
                        </button>
                      </li>
                    ))}
                  </ul>
                </aside>
             )}
          </div>
        );
      };
      
      const App = () => {
        const { useState, useEffect, useCallback } = React;
        const [view, setView] = useState('dm');

        const handleHashChange = useCallback(() => {
          setView(window.location.hash === '#/player' ? 'player' : 'dm');
        }, []);

        useEffect(() => {
          window.addEventListener('hashchange', handleHashChange);
          handleHashChange();
          return () => window.removeEventListener('hashchange', handleHashChange);
        }, [handleHashChange]);

        return (
          <React.Fragment>
            {view === 'dm' ? <DMView /> : <PlayerView />}
          </React.Fragment>
        );
      };

      const rootElement = document.getElementById('root');
      if (rootElement) {
        const root = ReactDOM.createRoot(rootElement);
        root.render(<App />);
      } else {
        console.error('Failed to find the root element');
      }

    </script>
  </body>
</html>